6 
fluctuations, we applied a multi-step correction process as illustrated in Fig. 2 (block with light 
blue background). First, ğ‘‹ğ‘‹(ğœğœ) was scaled to [1, 1.5] using equation: 
ğ‘¥ğ‘¥(ğœğœ) =
ğ‘‹ğ‘‹(ğœğœ) âˆ’minàµ«ğ‘‹ğ‘‹(ğœğœ)àµ¯
maxàµ«ğ‘‹ğ‘‹(ğœğœ)àµ¯âˆ’minàµ«ğ‘‹ğ‘‹(ğœğœ)àµ¯Ã— 0.5 + 1,
(8) 
where ğ‘¥ğ‘¥(ğœğœ) is the scaled measured ACF. Second, ğ‘¥ğ‘¥(ğœğœ) was fitted with a single exponential decay 
function, ğ‘“ğ‘“(ğœğœ) = ğ‘ğ‘+ ğ‘ğ‘ğ‘’ğ‘’ğ‘ğ‘ğ‘ğ‘. Third, we calculated the standard deviation of the residuals for each ğœğœ, 
i.e., ğœğœ= ğ‘ ğ‘ ğ‘ ğ‘ ğ‘ ğ‘ àµ«ğ‘¥ğ‘¥(ğœğœ) âˆ’ğ‘“ğ‘“(ğœğœ)àµ¯, std() is the standard deviation calculation function used in MATLAB. 
We obtained five sequences of ğœğœ from the five tests and calculated their mean and standard 
deviation. The averaged sequence was then scaled by Â±30% to encompass the variability observed 
across the tests (actual range is from -27.8% to +30.1% relative to the averaged sequence). This 
yielded three levels of ğœğœ: the averaged ğœğœ, +30% and â€“30% from mean. Finally, the three levels of 
ğœğœ are substituted into a Gaussian distribution model with zero mean to generate noise and added 
to the simulated clean dataset44. In total, we generated 1,200,000 training data samples (through 
combination of 400k clean curves Ã— 3 noise levels). Notably, we rescaled each noise-added curve 
with the same method (Eq. 8) prior to training. Likewise, any experimental SPAD ACF is scaled 
with Eq. (8) before input to the model, to maintain consistency between training and inference. 
The data processing protocol is illustrated in Fig. 2, including five parts: noise calculation, training 
dataset generation, test dataset generation, model training, and regression. 
 
Fig. 2 Flowchart of the data processing protocol. The process consists of five main components: (1) the 'Noise 
Calculation' block, which calculates the standard deviation from experimental baseline data; (2) the 'Dataset 
Generation' block, which outlines the procedure for generating clean data and adding noise; (3) the 'Model Training' 
block, which describes the training of the model on a GPU; (4) the â€˜Test Datasetâ€™ block, which illustrates the test 
dataset generation using MC simulation to assess our model, and (5) the 'Regression' block, which represents real-
time CBFi/rCBFi display using the trained model and the preparation of experimental data before input to the 
model. 
