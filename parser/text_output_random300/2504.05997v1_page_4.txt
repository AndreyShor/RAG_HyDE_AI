4
If not, let j be the ï¬rst position where (Ëœs1)j Ì¸= (Ëœs2)j. We can assume j = 1. If not, we can swap the ï¬rst and j-th qubit - this
state will be UMA if and only if |ÏˆâŸ©was UMA.
So without loss of generality, we can write:
|ÏˆâŸ©= Î±|+âŸ©|Ëœsâ€²
1âŸ©+ Î²|âˆ’âŸ©|Ëœsâ€²
2âŸ©.
and it will sufï¬ce to prove this is an UMA state. If Ëœsâ€²
1 = Ëœsâ€²
2, we are done as |ÏˆâŸ©factorizes, and the tensor product of a UMA
state (on the ï¬rst qubit by previous analysis) and another UMA state is UMA.
If Ëœsâ€²
1 Ì¸= Ëœsâ€²
2, deï¬ne U as the (n âˆ’1)-qubit diagonal unitary such that
|Ëœsâ€²
2âŸ©= U|Ëœsâ€²
1âŸ©.
Note that U is a diagonal unitary with Â±1 on the diagonal. Deï¬ne the Hadamard-controlled-U:
hcU = |+âŸ©âŸ¨+| âŠ—Inâˆ’1 + |âˆ’âŸ©âŸ¨âˆ’| âŠ—U.
Note that: (1)
hcU(Î±|+âŸ©|Ëœsâ€²
1âŸ©+ Î²|âˆ’âŸ©|Ëœsâ€²
1âŸ©) = |ÏˆâŸ©,
and (2) hcU is a block matrix with blocks (I + U)/2 on the diagonal and (I âˆ’U)/2 on the antidiagonal.
Note that in each row, we have only one non-zero element. So this is a permutation matrix. For a permutation matrix U, it
holds that |ÏˆâŸ©is UMA if and only if U|ÏˆâŸ©is UMA.
So since
Î±|+âŸ©|Ëœsâ€²
1âŸ©+ Î²|âˆ’âŸ©|Ëœsâ€²
1âŸ©
is UMA by previous analysis, so is |ÏˆâŸ©.
Next, we present the two key probability distribution decomposition lemmas in the language of probability vectors, i.e.,
vectors p = (pj)j, P
j pj = 1, pj â‰¥0, encoding the probability of the measurement of each of the bitstrings (indexed by j).
We will say a (probability) vector is k-sparse if it has at most k non-zero entries.
Lemma 4. Every N-dimensional probability vector p can be expressed as a uniform mixture of N 3-sparse probability vectors.
That is, there exists a set {q(i)}i of N 3-sparse probability vectors such that
p =
X
i
1
N q(i).
Proof. We give a constructive proof by showing there exists an allocation matrix Q âˆˆRNÃ—N of p such that the column sum
P
i Qij = pj and the row sum P
j Qij = 1/N, which is also 3-row-sparse. The 3-sparse probability vectors are the rows of the
Q, i.e., q(i)/N is the ith row of Q. We assume p1 â‰¤p2 â‰¤Â· Â· Â· â‰¤pN w.l.o.g. Let k be the smallest index such that pk+1 â‰¥1/N.
Note k = 1 if the distribution is uniform and can be as large as N âˆ’1, but not N.
The general idea is that we ï¬rst allocate p1, . . . , pk to the ï¬rst k diagonal entries of Q. Since p1 â‰¤p2 â‰¤Â· Â· Â· â‰¤pk â‰¤1/N, we
have some capacity left on each row, and hence we can further try to spread out pk+1 to the ï¬rst k rows. After pk+1 is fully
spread out, we proceed with pk+2 and so on. Note that whenever the ï¬rst rows are out of capacity, we will proceed using the
remaining N âˆ’k rows. The matrix Q can be constructed and veriï¬ed with the following three steps.
Step 1: Initialization. Q =

Q0 0
0
0

, Q0 =
ï£®
ï£¯ï£¯ï£°
p1
0
Â· Â· Â·
0
0
p2 Â· Â· Â·
0
...
...
...
...
0
0
Â· Â· Â· pk
ï£¹
ï£ºï£ºï£».
Step 2: Iterate over â„“= k + 1, . . . , N. For each iteration, we spread out pâ„“to the â„“column of Q as follows. For i running from
1 to N, we set
Qiâ„“= min
 1
N âˆ’
X
j
Qij, pâ„“âˆ’
X
Î±
QÎ±â„“

.
(12)
Note that, N âˆ’1 âˆ’P
j Qij is the remaining capacity of row i (recall each row sums to 1/N) and pâ„“âˆ’P
Î±<i QÎ±â„“is the residual
of pâ„“after spreading it over the ï¬rst i âˆ’1 row. Two indicator functions check if a row is out of capacity or pâ„“is completely
spread out.
