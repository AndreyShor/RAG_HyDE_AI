4
We observe that the average over 50 random trajec-
tories γ (red diamonds, Fig.
2) follows the evolution
obtained by RGD remarkably well. From the inset plot
that shows the fidelity error for a smaller step size ∆β,
we also see that the variance of the fidelity error can be
controlled through ∆β. Indeed, the plot suggests that
the smaller the step size ∆β, the closer a random tra-
jectory comes to the evolution obtained from RGD. This
observation can be made precise through the following
Theorem.
Theorem 2: The average fidelity error ¯εn = Eγ[ε(γ)
n ]
after n steps of SRGD with step size ∆β = β
n is upper
bounded by
bn = 9
2
p
2∆β∥H∥∞D

e8β∥H∥∞−1
 1
2 ,
(12)
for sufficiently large n. For any δ > 0, the probability that
a state created through SRGD will give rise to a fidelity
error greater than bn + δ is upper bounded by
Pr(ε(γ)
n
> bn + δ) ≤8∆β∥H∥∞D2
δ2

e8β∥H∥∞−1

(13)
We prove Theorem 2 in Appendix B by establishing a
recursion relation for the variance similar to (6) and then
applying the Chebyshev inequality.
Theorem 2 shows that by choosing the step size ∆β,
we can control the deviation δ from the average fidelity
error upper bound bn. Since bn can also be controlled in
the same way, we see that a random state |χ(γ)
n ⟩created
through SRGD may be made arbitrarily close to the ITE
state. This observation provides an interesting perspec-
tive of SRGD as “cooling” the initial state |ψ0⟩to the
ground state of H.
Discussion – Each step of SRGD is efficiently im-
plementable on a quantum computer.
The gates
V (j)
k
,
generated by Pauli operators,
can be imple-
mented by a quantum circuit of depth at most linear
in the number of qubits.
However, the overall run-
time O(β∥H∥∞D2 exp(8β∥H∥∞)) of the randomized al-
gorithm cannot be efficient in general for complexity rea-
sons [40], which is reflected in Theorem 2 by the depen-
dence on D = 22N −1.
In contrast, the lower bound for the average energy
change (10) suggests that the complexity of SRGD scales
inversely with the smallest coefficient Cj = ⟨gradJ, iPj⟩2
of the Riemannian gradient (taken over all steps). Con-
sequently, we expect that if there exists a constant α > 0
such that Cj does not vanish faster than O(N −α), the
ITE state can be prepared in polynomially many steps.
As the Riemannian gradient depends on the Hamiltonian
H and the state |χ(γ)
k ⟩, a more efficient sampling strategy
should exploit additional properties of H and |χ(γ)
k ⟩.
For
example,
consider
the
Riemannian
gradient
[H, |χ(γ)
k ⟩⟨χ(γ)
k |] at a random state |χ(γ)
k ⟩that has sup-
port on only a polynomially (in N) sized subset of Pauli
operators at each step k. We then may instead sample
Figure 2.
Fidelity error between the ITE state (1) with
β = 1 and the state (4) created by Riemannian gradient de-
scent (blue) for a single qubit with initial state |ψ0⟩= |+⟩and
Hamiltonian H = Z given by the Pauli-Z operator. Plotted as
a function of the number of steps k for a step size ∆β = β/n
where n = 300. The grey lines show the error obtained from
stochastic Riemannian gradient descent implemented by pro-
jecting the Riemannian gradient in each step into a uniformly
random tangent space direction. The red diamonds show the
average over 50 trajectories (only 10 are shown). In the inset
plot the fidelity error is shown for n = 3000.
only over this subset, giving rise to an effective sample
space of dimension D = poly(N). In practice, we can
only hope that the commutator [H, |χ(γ)
k ⟩⟨χ(γ)
k |] is ap-
proximately supported on a polynomially sized subset
of Pauli operators. We observe that such a scenario is
possible if the state |χ(γ)
k ⟩has finite correlation length,
and H is a geometrically local Hamiltonian.
The fi-
nite correlation length suggests that expectation values
of Pauli operators P, ⟨P⟩= ⟨χ(γ)
k | P |χ(γ)
k ⟩, will decay
exponentially with the support of P. This implies that
|χ(γ)
k ⟩⟨χ(γ)
k | ≈P
P ∈S⟨P⟩P where S is a poly(N) sized
set of all Pauli operators with support under some fixed
constant. In turn, this would imply that [H, |χ(γ)
k ⟩⟨χ(γ)
k |]
would be well approximated using only poly(N) Pauli
operators.
We also expect that the speed of convergence of RGD
to the ITE state can be improved by utilizing higher or-
der methods in which the step size ∆β becomes step de-
pendent. For example, the step size ∆β may be chosen
by employing second derivative information [17, 41]. In
general, efficient approximations of the Riemannian gra-
dient could also be informed by tensor network [42, 43],
Bayesian, and machine learning approaches [44] that aim
to learn the Riemannian gradient.
Conclusion – In this work we showed that quantum
imaginary time evolution can be understood as Rieman-
nian gradient descent that minimizes the energy of the
system. We derived a rigorous bound for the error be-
tween the states created through imaginary time evolu-
tion and Riemannian gradient descent that can be con-
