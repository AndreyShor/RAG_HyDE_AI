Render
SVG-IR Framework      (Sec. 4.2)
Loss
GT
Vertex Shading
ğ’„ğ’Š
{ğ‘´}
Vertex Colors
ğ‘£
ğ’„ğ’Š
ğŸ
ğ’„ğ’Š
ğŸ‘
ğ’„ğ’Š
ğŸ
ğ’„ğ’Š
ğŸ
ğ‘¢
Fragment Shading
Physically-based 
Lighting
(Sec. 4.3)
Spatially-varying Gaussian Splatting
Vertex 
Material Attributes
ğ’‚ğ’Š
{ğ‘´}, âˆ†ğ‘ğ’Š
{ğ‘´}, ğ‘Ÿğ’Š
{ğ‘´}
Spatially-varying Gaussian representation                    
                   (Sec. 4.1)
ğ›´ğ‘–, ğœ‡ğ‘–, ğ‘ğ‘–, Î±ğ‘–
Pre-trained
Gaussian Attributes
Figure 3. Overview of our framework. We propose a novel SVG-IR framework. Within this framework, we introduce a Spatially-
varying Gaussian representation capable of spatially variability with material attributes. We employ SVG splatting, analogous to vertex
and fragment shading in the traditional triangle rendering pipeline, to leverage the improved appearance capability of SVGs. Additionally,
we present a physics-based lighting model that enforces additional physical constraints to facilitate the decoupling of lighting and material
properties.
Next, we provide details of Gaussian fragment shading.
During rasterization, we compute the coordinates u, v in the
tangent space of Gaussian surfel[5] i corresponding to pixel
u in the screen space:
di = Jâˆ’1
pr (u âˆ’ui) ,
(6)
(u, v) =
di
S[: 2] + Î´ ,
(7)
where di is the displacement from the pixel center to the
Gaussian center in the tangent space, Jâˆ’1
pr is the Jacobian
of the inverse mapping from a pixel in the image space to
the tangent space of each Gaussian and Î´ is an offset (set as
0.1).
In practice, we compute pixelâ€™s color by bilinear interpo-
lation, followed by alpha blending:
ci = BilinearInterp(c{M}
i
, u, v),
C =
n
X
i=0
ciÎ±iTi.
(8)
Inverse rendering framework. With established Gaussian
primitives and their rendering scheme, we build our multi-
stage inverse rendering framework, as shown in Fig. 3.
Firstly, given multiple views, we utilize Gaussian Sur-
fels [5] to optimize Gaussian attributes as the initialization.
Then, we construct Spatially-varying Gaussians with at-
tributes (Î£i, Âµi, ci, oi) inherited from the pre-trained Gaus-
sians and the material attributes of Gaussian vertices (i.e.,
a{M}
i
, r{M}
i
, âˆ†N {M}
i
). Our framework optimizes the at-
tributes of the Gaussian vertices. Using SVG splatting, we
render the images and compute the corresponding loss func-
tions to guide the optimization.
4.3. Physically-based Illumination
A key of decomposing materials and lighting is the illu-
mination model, including both direct lighting and indi-
rect lighting, particularly for scenes with occlusions. Exist-
ing GS-based IR methods model the indirect illumination
Ours
Relightable 3DGS
GS-IR
Ã—2
Render with indirect illumination only
GT
Figure 4. The results of rendering using only indirect lighting. We
multiplied the brightness of the right half by two for better view-
ing. GS-IR fails to capture the effects of light reflections from ob-
jects as it only models brightness. Meanwhile, Relightable 3DGS
lacks supervision for indirect lighting, leading to unnatural results.
In contrast, our physically-based lighting model produces more
natural rendering results.
with trainable SHs which learn either the residual light-
ing [6, 20, 24] or the residual colors [11].
While these
unconstrained manner improves NVS quality, the indirect
lighting is unnatural, due to the lack of physical constraints.
We address this issue by introducing physically-based illu-
mination.
In our SVG-IR, we compute the global illumination for
each Gaussian vertex in the Gaussian vertex shading. Given
a Gaussian vertex x, and view direction Ï‰o, its radiance
Lo(x, Ï‰o) is defined by the rendering equation [15]:
Lo(x, Ï‰o) =
Z
â„¦
f(x, a, r, Ï‰i, Ï‰o)Li(x, Ï‰i)(Ï‰i Â· n)dÏ‰i,
(9)
where â„¦is the upper hemisphere of the Gaussian defined
by geometry normal N g
i , f is the Disney Principled BRDF,
a is albedo, r is roughness, Ï‰i is the incident direction and
n is the shading normal of the shading point x.
We solve the above integral by uniformly sampling K di-
rections within â„¦, and then compute the incoming radiance
Li(x, Ï‰i) along each direction. Here, Li(x, Ï‰i) is computed
per Gaussian, instead of per Gaussian vertex, as the incom-
ing radiance in a small region tends to be similar. Li(x, Ï‰i)
can be separated as
Li(x, Ï‰i) = Ldir
i (x, Ï‰i)V (x, Ï‰i) + Lind
i
(x, Ï‰i),
(10)
